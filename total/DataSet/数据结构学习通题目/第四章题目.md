# 第四章题目

## 选择题

### 1.![alt text](<PicturE/屏幕截图 2026-01-01 191919.png>)

**答案是A；**

### 2.![alt text](<PicturE/屏幕截图 2026-01-01 193104.png>)

这个题的意思是给了一个三维数组  
\[
A[0..4, \ -1..-3, \ 5..7]
\]  
我们要计算数组一共有多少个元素。

---

#### 1. 理解下标范围
三个维度的下标范围分别是：  

1. 第一维：\( 0..4 \)  
长度：\( 4 - 0 + 1 = 5 \)  

2. 第二维：\( -1..-3 \)  
注意这是从 \(-1\) 到 \(-3\)，是递减的，第二维长度仍然是：  
\[
(-3) - (-1) + 1 = -3 + 1 + 1 = -2 + 1 = -1 + 1 + 1
\]  
更直接：  
长度 \( = | (-3) - (-1) | + 1 = | -3 + 1 | + 1 = | -2 | + 1 = 2 + 1 = 3 \)  
或直接：上限 \( u = -1 \)，下限 \( l = -3 \)  
\[
\text{长度} = u - l + 1 = (-1) - (-3) + 1 = -1 + 3 + 1 = 3
\]
正确。

3. 第三维：\( 5..7 \)  
长度：\( 7 - 5 + 1 = 3 \)

---

#### 2. 总元素个数
\[
5 \times 3 \times 3 = 45
\]

---

**答案：B** ✅

## 判断题

### 1.![alt text](<PicturE/屏幕截图 2026-01-01 195353.png>)

好，整理如下：

---

### 用“字符从 1 开始编号，next[j] = 当第 j 个字符失配时，应跳转到哪个字符位置继续匹配”的定义（即计算时 next[1]=0）：

模式串 `P = "abaabcac"`，长度 8，下标 1 到 8：  
P[1]=a, P[2]=b, P[3]=a, P[4]=a, P[5]=b, P[6]=c, P[7]=a, P[8]=c

计算 next 数组（j 从 1 到 8）：

1. **j=1**，`next[1]=0`
2. **j=2**，`P[1]` 的前后缀无相同，`next[2]=1`
3. **j=3**，子串 `"ab"`，`next[3]=1`
4. **j=4**，子串 `"aba"`，最长相等前后缀 `"a"`，长度 1 → `next[4]=2`
5. **j=5**，子串 `"abaa"`，最长相等前后缀 `"a"`，长度 1 → `next[5]=2`
6. **j=6**，子串 `"abaab"`，最长相等前后缀 `"ab"`，长度 2 → `next[6]=3`
7. **j=7**，子串 `"abaabc"`，最长相等前后缀无相同 → `next[7]=1`
8. **j=8**，子串 `"abaabca"`，最长相等前后缀 `"a"`，长度 1 → `next[8]=2`

得到 next 数组（j=1..8）：  
**0 1 1 2 2 3 1 2**  
写成序列就是：**`01122312`** ✅

---

`因此，原题说法是正确的。`

## 填空题

### 1.![alt text](<PicturE/屏幕截图 2026-01-01 195824.png>)

这个函数调用看起来是 **字符串查找子串** 的操作，可能类似 Pascal 语言或某些教材里的 `index(s, t, start)` 函数，它返回子串 `t` 在字符串 `s` 中**从 start 位置开始**第一次出现的起始位置，如果找不到则返回 0（或 -1，取决于定义）。  

这里：  
- 主串 `s = "datastructure"`  
- 子串 `t = "str"`  
- 起始位置 `start = 1`（字符串下标从 1 开始）  

---

**查找过程**：  
`"datastructure"` 中从第 1 个字符开始寻找 `"str"`：  
1. `"datastructure"` → 从 `'d'` 开始，`"dat"` 不匹配 `"str"`  
2. 滑动直到发现子串：  
   `"datastructure"` 中第 5 到 7 个字符是 `"str"`（`"data"` 之后是 `"struc"` 的 `"str"`）。  

检查位置：  
- `"datastructure"` 拆开：  
  d(1) a(2) t(3) a(4) s(5) t(6) r(7) u c t u r e  
  从索引 5 开始：`'s'`, `'t'`, `'r'` 正好匹配 `"str"`。  

所以找到 `"str"` 的起始位置是 **5**。

---

**答案**：**5** ✅

### 2.![alt text](<PicturE/屏幕截图 2026-01-03 161456.png>)

#### 三、KMP算法的核心思想
核心：利用已匹配的信息，避免不必要的回溯
text
例子：主文本串 T = "ABABABABC"
       模式串 P = "ABABC"
       
暴力匹配过程：
T: A B A B A B A B C
P: A B A B C      ← 第5个字符不匹配
    重新开始匹配...

KMP匹配过程：
T: A B A B A B A B C
P: A B A B C      ← 第5个字符不匹配
    这里已经匹配了"ABAB"，利用这个信息
    模式串可以滑动到：
T: A B A B A B A B C
P:     A B A B C   ← 直接从这里开始比较
#### 四、KMP算法关键：部分匹配表（Prefix Table/LPS数组）
1. 最长公共前后缀（Longest Proper Prefix which is also Suffix）
text
模式串: "ABABC"
索引:   0 1 2 3 4
字符:   A B A B C

对于每个位置i，找出前缀=后缀的最大长度：

i=0: 字符串"A"      → 长度: 0
i=1: 字符串"AB"     → 长度: 0 (前缀"A"≠后缀"B")
i=2: 字符串"ABA"    → 长度: 1 (前缀"A"=后缀"A")
i=3: 字符串"ABAB"   → 长度: 2 (前缀"AB"=后缀"AB")
i=4: 字符串"ABABC"  → 长度: 0

得到的LPS数组: [0, 0, 1, 2, 0]
2. LPS数组的作用
当匹配失败时，告诉我们应该将模式串向右移动多少位：

移动位数 = 已匹配的字符数 - 最后一个匹配字符对应的LPS值

直接跳转到LPS[j-1]的位置继续匹配

#### 五、KMP算法步骤
1. 构建LPS数组
java
public int[] computeLPS(String pattern) {
    int m = pattern.length();
    int[] lps = new int[m];
    int len = 0;  // 当前最长公共前后缀长度
    int i = 1;
    
    while (i < m) {
        if (pattern.charAt(i) == pattern.charAt(len)) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];  // 回退
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}
2. KMP搜索
java
public int KMPSearch(String text, String pattern) {
    int n = text.length();
    int m = pattern.length();
    int[] lps = computeLPS(pattern);
    
    int i = 0;  // text的索引
    int j = 0;  // pattern的索引
    
    while (i < n) {
        if (text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
        }
        
        if (j == m) {
            System.out.println("找到模式串，起始位置: " + (i - j));
            j = lps[j - 1];  // 继续寻找下一个匹配
        } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
            if (j != 0) {
                j = lps[j - 1];  // 利用LPS数组跳转
            } else {
                i++;
            }
        }
    }
    return -1;  // 如果没找到
}
#### 六、时间复杂度分析
1. LPS数组构建：O(m)
每个字符最多被比较一次

len指针最多增加m次

2. 搜索过程：O(n)
主文本串指针i只前进不后退

模式串指针j通过LPS数组跳转

3. 总时间复杂度：O(n + m)
#### 七、KMP算法示例
java
public class KMPExample {
    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";
        
        int[] lps = computeLPS(pattern);
        System.out.print("LPS数组: ");
        for (int val : lps) {
            System.out.print(val + " ");
        }
        System.out.println();
        
        KMPSearch(text, pattern);
    }
    
    // 输出：
    // LPS数组: 0 0 1 2 0 1 2 3 4 
    // 找到模式串，起始位置: 10
}
#### 八、KMP算法优点和缺点
优点：
时间复杂度低：O(n+m)，比暴力匹配的O(m*n)好

不需要回溯文本串指针：只扫描一次文本串

适合流式处理：可以边读取边匹配

缺点：
需要额外空间：存储LPS数组，O(m)空间复杂度

实现相对复杂：比暴力匹配复杂

预处理开销：对于很短的模式串，可能不如暴力匹配快