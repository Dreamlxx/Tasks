# 四个算法

## 深度优先遍历（前序遍历）

### 一、准备阶段的代码

![alt text](<图片2/屏幕截图 2025-11-18 152229.png>)

Vertex（char）是顶点；Edge（int）是边

### 二、深度优先算法代码

![alt text](<图片2/屏幕截图 2025-11-18 152806.png>)

### 三，创建图

![alt text](<图片2/屏幕截图 2025-11-19 194456.png>)

#### 遍历数组，赋值为零

![alt text](<图片2/屏幕截图 2025-11-19 194800.png>)

![alt text](<图片2/屏幕截图 2025-11-19 194825.png>)

#### 以对角线赋值

![alt text](<图片2/屏幕截图 2025-11-19 195122.png>)

![alt text](<图片2/屏幕截图 2025-11-19 195205.png>)

## 广度优先遍历（层序遍历）

### 一、

![alt text](<图片2/屏幕截图 2025-11-19 203614.png>)

### 二、造图

![alt text](<图片2/屏幕截图 2025-11-19 203724.png>)

![alt text](<图片2/屏幕截图 2025-11-19 203752.png>)

![alt text](<图片2/屏幕截图 2025-11-19 203759.png>)

### 三、算法实现

![alt text](<图片2/屏幕截图 2025-11-19 203921.png>)

## 最小生成树-普利姆

（考试要求掌握画图）

从一个顶点开始找最小生成树

![alt text](<图片2/屏幕截图 2025-11-19 204338.png>)

### 一、前置

![alt text](<图片2/屏幕截图 2025-11-19 204507.png>)

### 二、造图图

![alt text](<图片2/屏幕截图 2025-11-19 204844.png>)

![alt text](<图片2/屏幕截图 2025-11-19 204917.png>)

![alt text](<图片2/屏幕截图 2025-11-19 205007.png>)

修改对角线的下一半

![alt text](<PhotoALL/屏幕截图 2025-11-19 205330.png>)

### 三、算法实现（

![alt text](<PhotoALL/屏幕截图 2025-11-19 205438.png>)

![alt text](<PhotoALL/屏幕截图 2025-11-19 205847.png>)

![alt text](<PhotoALL/屏幕截图 2025-11-19 210741.png>)

## 最小生成树-克鲁斯卡尔

### ***从一个边（最短边）开始生成最小生成树***

![alt text](<PhotoALL/屏幕截图 2025-11-19 211003.png>)
